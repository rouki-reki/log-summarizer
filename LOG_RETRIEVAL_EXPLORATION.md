# ログ取得アルゴリズムの探索: 望ましい結果の考察 (改訂案)

## 1. 目的

(変更なし)

## 2. 背景と基本的な考え方

(変更なし)

## 3. 初期状態の定義 (例: 10,000ログ)

(変更なし)

## 4. 提案アルゴリズム (未要約ノード活用案)

ユーザーからのフィードバックと「未要約ノード」のアイデアに基づき、以下のアルゴリズムを提案する。

**入力**: 取得したいノード数 `k`

**出力**: 取得されたノードのリスト (Node[])

**処理:**

1.  **k <= 6 の場合:**
    *   システム内の全L0ノードをタイムスタンプの **新しい順** にソートする。
    *   ソートしたリストから、最大 `k` 個のL0ノードを取得して返す。
    *   (この場合、以降のステップは実行しない)

2.  **k > 6 の場合:**
    *   **ステップ 2.1: 最新L0ノードの取得**
        *   含めるL0ノード数 `numL0` を計算: `numL0 = max(6, floor(k * 0.5))`
        *   システム内の全L0ノードをタイムスタンプの **新しい順** にソートする。
        *   ソートしたリストから、最大 `numL0` 個、かつ最大 `k` 個のL0ノードを取得し、結果リスト `resultNodes` に追加する。
    *   **ステップ 2.2: 残り枠の計算**
        *   `remainingK = k - resultNodes.length`
    *   **ステップ 2.3: 残り枠の補充 (未要約ノードを使用)**
        *   もし `remainingK > 0` ならば:
            *   システム内の **未要約ノード** (`parentId === null`) をすべて収集する。
            *   収集した未要約ノードを、まず **レベルの高い順 (L5, L4, L3...)**、次に同じレベル内では **タイムスタンプの新しい順** でソートする。
            *   ソートしたリストの先頭から順に、最大 `remainingK` 個のノードを取得し、`resultNodes` に追加する。
    *   **ステップ 2.4: (課題) さらに残り枠がある場合**
        *   ステップ 2.3 を実行しても `resultNodes.length` が `k` に満たない場合、どうするか？ (後述の「5. 未解決の課題と議論ポイント」を参照)
        *   **暫定案**: 現時点では、取得できたノードのみを返す (`k` に満たなくても許容する)。
    *   **ステップ 2.5: 結果の返却**
        *   `resultNodes` を返す (リスト内の順序は、最新L0が先、次に未要約ノードが高いレベル→新しい順)。

## 5. シナリオ再考察 (提案アルゴリズム適用)

10,000ログの初期状態 (未要約: L5x3, L4x1) に提案アルゴリズムを適用する。

---

### シナリオ 1: `k = 10`

1.  `k > 6` なのでステップ2へ。
2.  **2.1 (最新L0)**: `numL0 = max(6, floor(10 * 0.5)) = 6`。最新L0を6個取得。`resultNodes = [最新L0 x 6]`。
3.  **2.2 (残り枠)**: `remainingK = 10 - 6 = 4`。
4.  **2.3 (未要約補充)**: `remainingK > 0`。未要約ノード `[L5_3, L5_2, L5_1, L4_1]` (レベル高→新順) を取得候補とする。先頭から `remainingK = 4` 個取得し、`resultNodes` に追加。
5.  **2.4 (さらに残り枠)**: なし。`resultNodes.length = 6 + 4 = 10`。
6.  **2.5 (結果)**: `[最新L0 x 6, L5_3, L5_2, L5_1, L4_1]` (合計10ノード)
    *   **考察**: 最新の詳細ログ6件と、最も古い期間の概要（L5, L4）が得られる。中間のL1～L3の情報はないが、`k` が小さい場合はこれが妥当かもしれない。

---

### シナリオ 2: `k = 50`

1.  `k > 6` なのでステップ2へ。
2.  **2.1 (最新L0)**: `numL0 = max(6, floor(50 * 0.5)) = 25`。最新L0を25個取得。`resultNodes = [最新L0 x 25]`。
3.  **2.2 (残り枠)**: `remainingK = 50 - 25 = 25`。
4.  **2.3 (未要約補充)**: `remainingK > 0`。未要約ノード `[L5_3, L5_2, L5_1, L4_1]` を取得候補とする。先頭から `remainingK = 25` 個取得しようとするが、4個しかないので4個取得し、`resultNodes` に追加。
5.  **2.4 (さらに残り枠)**: あり。`resultNodes.length = 25 + 4 = 29`。`k=50` に満たない。
    *   **暫定案適用**: 現状では `k` に満たなくても、取得できた29ノードを返す。
6.  **2.5 (結果 - 暫定)**: `[最新L0 x 25, L5_3, L5_2, L5_1, L4_1]` (合計29ノード)
    *   **考察**: 最新L0は十分だが、未要約ノードだけでは `k` を満たせない。中間の期間 (L1-L3) の情報が欠落している。この結果は「望ましい」とは言えない可能性がある。

---

### シナリオ 3: `k = 200`

1.  `k > 6` なのでステップ2へ。
2.  **2.1 (最新L0)**: `numL0 = max(6, floor(200 * 0.5)) = 100`。最新L0を100個取得。`resultNodes = [最新L0 x 100]`。
3.  **2.2 (残り枠)**: `remainingK = 200 - 100 = 100`。
4.  **2.3 (未要約補充)**: `remainingK > 0`。未要約ノード `[L5_3, L5_2, L5_1, L4_1]` を取得候補とする。先頭から `remainingK = 100` 個取得しようとするが、4個しかないので4個取得し、`resultNodes` に追加。
5.  **2.4 (さらに残り枠)**: あり。`resultNodes.length = 100 + 4 = 104`。`k=200` に満たない。
    *   **暫定案適用**: 現状では `k` に満たなくても、取得できた104ノードを返す。
6.  **2.5 (結果 - 暫定)**: `[最新L0 x 100, L5_3, L5_2, L5_1, L4_1]` (合計104ノード)
    *   **考察**: k=50 と同様に、未要約ノードだけでは不足する。

---

## 6. 未解決の課題と議論ポイント

1.  **残り枠補充の改善 (ステップ 2.4)**: 未要約ノードだけでは `k` に満たない場合、どうするか？
    *   **案1 (要約済み高レベルノード追加)**: 要約済みのノード (`parentId !== null`) の中で、レベルが高く新しいものから順に追加する？ (例: L3 -> L2 -> L1 の順で最新のものを追加)
    *   **案2 (全ノードから補充)**: 取得済みのノードを除き、残りの全ノードを「レベル高→新順」でソートし、`k` に達するまで追加する？
    *   **案3 (L0追加)**: 単純に最新L0の取得数を増やす？ (L0の割合目標を上げる)
    *   **案4 (現状維持)**: `k` は努力目標とし、取得できたノード数で返す。シンプルだがユーザーの期待とずれる可能性。
    *   **議論**: どの案が「最新は細かく、古いものは粗く」の意図に最も近いか？ 実装の複雑さとのトレードオフは？

2.  **重複排除**: 提案アルゴリズムでは、取得した最新L0ノード群の親であるL1ノードが、ステップ2.3やステップ2.4の補充で取得される可能性は低い（未要約ノードや高レベルノードが優先されるため）。しかし、完全に重複がないとは保証できない。
    *   **議論**: この程度の潜在的な重複は許容できるか？ それとも、より厳密な重複排除ロジック（実装複雑化）を検討すべきか？

3.  **L0の割合 (50%)**: この割合は固定で良いか？ `k` の値に応じて動的に変更する（例: `k` が大きいほどL0の割合を下げる）方がより良い結果になる可能性はあるか？

4.  **パフォーマンス**: 全ノードをソートする処理（特にL0）は、ノード数が膨大になるとパフォーマンスに影響を与える可能性がある。インデックスなどを活用した効率化が必要になるかもしれない（これは実装段階での検討事項）。

## 7. 次のステップ

1.  **議論**: この改訂案、特に「5. 未解決の課題と議論ポイント」について議論し、アルゴリズムの最終的な仕様（特にステップ2.4の処理）を決定する。
2.  **テスト計画更新**: 決定したアルゴリズム仕様に基づき `GET_LOGS_TEST_PLAN.md` の期待値を更新する。
3.  **実装**: 更新されたテスト計画に基づいて、テストコードと機能コードを実装する。

---