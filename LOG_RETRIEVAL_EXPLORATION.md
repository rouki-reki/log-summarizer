# ログ取得アルゴリズムの探索: 望ましい結果の考察

## 1. 目的

このドキュメントは、「Log Summarizer」における粒度調整ログ取得機能の「望ましい結果」を探ることを目的とする。特に、「最新の情報ほど詳細に（低レベルノード）、古い情報ほど要約された形で（高レベルノード）」、指定された件数 `k` に合わせて取得するための理想的なノード構成について考察する。これは、具体的なアルゴリズムを設計・実装する前の、共通認識形成のためのたたき台である。

## 2. 背景と基本的な考え方

*   **情報価値の非対称性**: 一般的に、ログデータは最新のものほど即時的な分析（エラー調査、現在の状態把握など）に価値があり、詳細な情報（生ログ = L0）が求められることが多い。
*   **過去データの役割**: 古いデータは、傾向分析、パフォーマンス推移、長期的な問題の特定などに役立つが、個々の詳細よりも要約された情報（L1, L2...）で十分な場合が多い。
*   **効率性**: 大量のログが存在する場合、すべてを生ログで取得・表示するのは非効率的であり、パフォーマンスや可読性の観点からも望ましくない。
*   **取得件数 `k` の意味**: ユーザーが指定する `k` は、「大体このくらいの情報量（ノード数）で状況を把握したい」という意図を表すと考えられる。必ずしも元ログ `k` 件分という意味ではない。
*   **バランス**: アルゴリズムは、`k` の値に応じて、最新の詳細情報と過去の要約情報のバランスを取る必要がある。

## 3. 初期状態の定義 (例: 10,000ログ)

考察のため、以下のような大規模なログが存在する状態を仮定する。

*   **入力**: 10,000件のログエントリ (L0) が順次追加された状態。
*   **生成されるノード (概算)**:
    *   Level 0 (LogNode): 10,000個
    *   Level 1 (SummaryNode): 10,000 / 5 = 2,000個
    *   Level 2 (SummaryNode): 2,000 / 5 = 400個
    *   Level 3 (SummaryNode): 400 / 5 = 80個
    *   Level 4 (SummaryNode): 80 / 5 = 16個
    *   Level 5 (SummaryNode): 16 / 5 = 3個 (余り L4 x 1)
    *   Level 6 (SummaryNode): 3 / 5 = 0個
*   **未要約ノードリスト (`parentId === null`)**:
    *   Level 4: 最新の1個
    *   Level 5: 最新の3個
    *   **合計**: 4個 (L4 x 1, L5 x 3)

## 4. 取得シナリオと「望ましい結果」の考察

指定された取得件数 `k` に対して、どのようなノード構成が理想的か、いくつかのシナリオで考察する。

---

### シナリオ 1: `k = 10` (非常に少ない件数)

*   **ユーザーの意図 (推測)**: 「直近で何が起こったか、ごく簡単な概要だけ知りたい」
*   **考えられるアプローチ**:
    *   **案A (最新L0特化)**: 最新のL0ノードを10個取得する。
        *   **メリット**: 直近の具体的なイベントがわかる。
        *   **デメリット**: 少し前の状況や全体像が全くわからない。
    *   **案B (最低L0 + 最新未要約)**: 最新L0を最低限 (例: 6個) 取得し、残りの枠 (10 - 6 = 4個) を最新の未要約ノード (L4 x 1, L5 x 3) で埋める。
        *   **結果**: [最新L0 x 6, 最新L4 x 1, 最新L5 x 3] (合計10ノード)
        *   **メリット**: 直近の具体例と、かなり古い期間の超概要がわかる。
        *   **デメリット**: 中間の期間の情報が抜け落ちる。L0とL4/L5の粒度のギャップが大きい。
    *   **案C (レベル混在)**: 最新L0を数個 (例: 5個) + 最新L1を数個 (例: 3個) + 最新L2を数個 (例: 2個) のように、低レベルのノードを優先しつつ混ぜる。
        *   **結果**: [最新L0 x 5, 最新L1 x 3, 最新L2 x 2] (合計10ノード)
        *   **メリット**: 比較的最近の情報を、少しずつ粒度を変えながら見れる。
        *   **デメリット**: 未要約の高レベルノードが無視される。アルゴリズムが複雑化する。
*   **議論**: `k` が小さい場合、どこまでのレベルのノードを含めるのが適切か？ 最新L0の最低保証数 (例: 6個) は妥当か？

---

### シナリオ 2: `k = 50` (中程度の件数)

*   **ユーザーの意図 (推測)**: 「最近の状況をある程度詳しく知りつつ、過去の概要も把握したい」
*   **考えられるアプローチ**:
    *   **案A (L0比率重視 + 未要約)**: L0の割合を `k` の約50% (25個) とし、最新L0を25個取得。残り枠 (50 - 25 = 25個) を未要約ノード (L4 x 1, L5 x 3) と、さらに古いレベルのノード (例: 最新のL3を 25 - 1 - 3 = 21個) で埋める。
        *   **結果**: [最新L0 x 25, 最新L4 x 1, 最新L5 x 3, 最新L3 x 21] (合計50ノード)
        *   **メリット**: 最新の詳細情報と、過去の概要（L3, L4, L5）を組み合わせられる。
        *   **デメリット**: L1, L2の情報が欠落する可能性がある。L3を21個も取るのは詳細すぎるかもしれない。
    *   **案B (レベル分散)**: 最新L0を最低限 (例: 6個) 取得。残り枠 (50 - 6 = 44個)。未要約ノード (L4 x 1, L5 x 3) を取得。残り枠 (44 - 4 = 40個)。残りをL3, L2, L1に割り振る。例えば、各レベルで表現される元ログ数が均等になるように？ または、単純に新しい順に各レベルから取得？
        *   **例**: [最新L0 x 6, 最新L4 x 1, 最新L5 x 3, 最新L3 x 8, 最新L2 x 10, 最新L1 x 12] (合計40ノード、残り枠0) ← 合計が合わない。割り振りが難しい。
        *   **メリット**: 幅広い期間と粒度の情報が得られる可能性がある。
        *   **デメリット**: アルゴリズムが非常に複雑になる。「望ましい」割り振りの定義が難しい。
    *   **案C (シンプルソート拡張)**: 未要約ノードを「レベル低→新順」でソート ([L4_1, L5_3, L5_2, L5_1])。これらをまず取得候補とする。次に、**すべての**ノードを「レベル低→新順」でソートし、まだ取得されていないノードを `k` 個になるまで追加する。
        *   **結果**: [L4_1, L5_3, L5_2, L5_1] + [最新のL0 x (50-4=46個)] ? ← これだと最新L0ばかりになる。
        *   **改良案**: 未要約ノード取得後、残り枠 `remainingK` を、L0, L1, L2... の各レベルの最新ノードに均等に割り振る？
*   **議論**: L0の割合 (50%) は固定が良いか？ `k` に応じて変えるべきか？ 各レベルへの割り振りをどう決定するか？

---

### シナリオ 3: `k = 200` (比較的多い件数)

*   **ユーザーの意図 (推測)**: 「最新の状況をかなり詳しく、かつ過去についても段階的に概要を把握したい」
*   **考えられるアプローチ**:
    *   **案A (L0比率 + 全レベル網羅)**: 最新L0を `k` の約50% (100個) 取得。残り枠 (200 - 100 = 100個)。未要約ノード (L4 x 1, L5 x 3) を取得。残り枠 (100 - 4 = 96個)。残りを最新のL3 (8個), 最新のL2 (40個), 最新のL1 (96 - 8 - 40 = 48個) で埋める。
        *   **結果**: [最新L0 x 100, 最新L4 x 1, 最新L5 x 3, 最新L3 x 8, 最新L2 x 40, 最新L1 x 48] (合計200ノード)
        *   **メリット**: 最新の詳細度が高く、過去のレベルも広くカバーできる。
        *   **デメリット**: L1の取得数が中途半端になる可能性がある。
    *   **案B (レベルごとの取得数上限)**: 各レベルごとに取得する最大数を設定する？ 例えば、L0は最大100個、L1は最大50個、L2は最大20個... のように。そして「レベル低→新順」で取得していく。
        *   **メリット**: 特定のレベルに偏りすぎるのを防げる。
        *   **デメリット**: 上限値の設定が難しい。`k` の値によっては上限に達しないレベルが多くなる。
*   **議論**: `k` が大きい場合、L0の割合は下げるべきか？ (例: 30%?)。古いレベルのノード（L4, L5など）は、未要約のものだけでなく、要約済みのもの（ただし最新のもの）も含めるべきか？

---

## 5. アルゴリズムへの示唆と曖昧性の許容

*   **厳密解は困難**: すべての `k` とログ状態に対して完璧に「望ましい」結果を返す単一の数式やアルゴリズムを定義するのは非常に難しい。
*   **ヒューリスティックなアプローチ**: いくつかのルールや優先順位に基づいた、現実的なアルゴリズム（ヒューリスティック）を目指すのが良さそう。
    *   最新L0の最低保証数 (例: 6個)
    *   最新L0の割合目標 (例: `k` の 30%～50% の範囲？)
    *   未要約ノードの優先取得
    *   残り枠の割り振り方（レベル優先？ 新しさ優先？ バランス？）
*   **曖昧性の許容**: 結果として返されるノードの組み合わせについて、「L1が3～5個」のように、ある程度の幅や曖昧さを持たせた期待値を設定することも検討する。アルゴリズムが複雑になりすぎるのを避けるため。
*   **パラメータ化**: L0の最低保証数や割合目標などをパラメータとして調整可能にする？

## 6. 次のステップ

1.  **議論**: このドキュメントの内容について議論し、各シナリオにおける「より望ましい」結果のイメージを共有・具体化する。
2.  **アルゴリズム要件定義**: 議論に基づき、実装すべきアルゴリズムの具体的なルールや優先順位を決定する。曖昧さを許容する範囲も定義する。
3.  **テスト計画更新**: 決定したアルゴリズム要件に合わせて `GET_LOGS_TEST_PLAN.md` の期待値を更新する。
4.  **実装**: 更新されたテスト計画に基づいて、テストコードと機能コードを実装する。

---